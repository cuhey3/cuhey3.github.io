<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <title></title>
    <style>
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th, td {
            padding: 5px;
        }
    </style>
</head>
<body>
<h2>WebRTCチャット</h2>
<label>
    <input type="radio" name="join-type" value="parent"/>既存ユーザー
</label>
<label>
    <input type="radio" name="join-type" value="child"/>新規参加
</label>
<div>
    <label>
        参加リクエストトークン
        <textarea id="offer-token-input" disabled></textarea>
    </label>
    <input type="button" id="offer-token-button" value="コピーする" disabled/>
</div>
<div>
    <label>
        参加許可トークン
        <textarea id="answer-token-input" disabled></textarea>
    </label>
    <input type="button" id="answer-token-button" value="読み込む" disabled/>
</div>
<div>
    <label>
        メッセージ
        <textarea id="message-input"></textarea>
    </label>
    <input type="button" id="message-send-button" value="送信"/>
</div>
<h3>チャット</h3>
<table>
    <thead>
    <tr>
        <th>time</th>
        <th>user</th>
        <th>comment</th>
    </tr>
    </thead>
    <tbody id="chat-messages-tbody">
    </tbody>
</table>
<script>
    const CONFIG_FOR_SENDER = {
        iceServers: [
            {
                urls: "stun:stun.l.google.com:19302",
            },
        ],
    };

    class Node {
        messages;
        userName;
        parent;
        parentConnectionInfos;
        children;
        childConnectionInfos;
        level;

        constructor() {
            this.userName = Math.ceil(Math.random() * 1000);
            this.parentConnectionInfos = [];
            this.childConnectionInfos = [];
            this.messages = [];
        }

        getParentUserName() {
            return this.parentConnectionInfos[0] && this.parentConnectionInfos[0].connectedUserName;
        }

        buildConnectionAsParent(index) {
            const self = this;
            const info = self.childConnectionInfos[index];
            info.connection.onicecandidate = function (event) {
                console.log('parent ice', event);
                if (!event.candidate) {
                    const answerObj = JSON.parse(JSON.stringify(info.connection.localDescription));
                    answerObj.userName = self.userName;
                    info.answerToken = JSON.stringify(answerObj);
                    answerTokenInput.value = info.answerToken;
                    if (info.isSpare) {
                        (async function () {
                            for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                    continue;
                                }
                                await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                    messageType: Message.SPARE_ANSWER_MESSAGE,
                                    body: info.answerToken,
                                    to: info.connectedUserName,
                                }));
                            }
                        })();
                    }
                }
            }
            info.connection.ondatachannel = function (event) {
                info.dataChannel = event.channel;
                event.channel.onopen = function () {
                    console.log(`with ${info.connectedUserName} as parent onopen`);
                    // parent の場合は、より親に送るか、子供全員に送るかで、
                    // その処理を接続確立のたびにセットするのはおかしい
                    messageSendButton.onclick = function () {
                        if (self.parentConnectionInfos[0] && !self.parentConnectionInfos[0].isClosed && !self.childConnectionInfos[0].isSpare) {
                            console.log('send message to parent', messageInput.value);
                            (async function () {
                                await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                                    from: self.userName,
                                    body: messageInput.value
                                }));
                            })();
                        } else {
                            console.log('send message to children', messageInput.value);
                            (async function () {
                                for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                    if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                        continue;
                                    }
                                    await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                        from: self.userName,
                                        body: messageInput.value,
                                    }));
                                }
                                addMessageToTable(self.userName, messageInput.value, null, self.messages);
                            })();
                        }
                    };
                    if (self.parentConnectionInfos[0]) {
                        (async function () {
                            await info.dataChannel.send(Message.toJson({
                                from: self.userName,
                                messageType: Message.CREATE_SPARE_OFFER_MESSAGE,
                                body: '',
                                args: [self.parentConnectionInfos[0].connectedUserName],
                            }));
                        })();
                    }
                    if (!info.isSpare) {
                        (async function () {
                            await info.dataChannel.send(Message.toJson({
                                messageType: Message.PAST_MESSAGES,
                                body: self.messages,
                            }));
                            if (!self.parentConnectionInfos[0] && self.childConnectionInfos.length === 1) {
                                await info.dataChannel.send(Message.toJson({
                                    messageType: Message.JOINED_MESSAGE,
                                    from: self.userName,
                                    body: 'joined.'
                                }));
                                addMessageToTable(self.userName, 'joined.', null, self.messages);
                            }
                        })();
                    }
                    info.isSpare = false;
                }

                event.channel.onmessage = function (event) {
                    console.log('from child message', event);
                    const message = Message.fromJson(event.data);
                    if (message.isSpareOffer()) {
                        (async function () {
                            await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                                userName: self.userName,
                                messageType: Message.CREATE_SPARE_ANSWER_MESSAGE,
                                body: message.body,
                                to: self.parentConnectionInfos[0].connectedUserName,
                            }));
                        })();
                        return;
                    } else if (message.isCreateSpareAnswer() && message.to === self.userName) {
                        console.log('get spare offer', message.body);
                        console.log('create spare answer logic start');
                        offerTokenInput.value = message.body;
                        const connectionInfo = new ConnectionInfo();
                        connectionInfo.isSpare = true;
                        connectionInfo.connectedUserName = JSON.parse(message.body).userName;
                        const connectionNumber = node.childConnectionInfos.push(connectionInfo);
                        node.buildConnectionAsParent(connectionNumber - 1);
                        console.log('create spare answer logic end');
                        return;
                    }
                    (async function () {
                        if (self.parentConnectionInfos[0] && !self.parentConnectionInfos[0].isClosed && !self.childConnectionInfos[0].isSpare) {
                            await self.parentConnectionInfos[0].dataChannel.send(event.data);
                        } else {
                            for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                    continue;
                                }
                                await self.childConnectionInfos[i].dataChannel.send(event.data);
                            }
                            addMessageToTable(message.from, message.body, null, self.messages);
                        }
                    })();
                }
                event.channel.onclose = function (event) {
                    info.isClosed = true;
                }
                event.channel.onerror = function (event) {
                    console.log('child connection error', event);
                }
            };
            (async function () {
                const offerTokenWithName = JSON.parse(offerTokenInput.value);
                info.connectedUserName = offerTokenWithName.userName;
                await info.connection.setRemoteDescription(new RTCSessionDescription(JSON.parse(offerTokenInput.value)));
                const answer = await info.connection.createAnswer();
                answer.userName = self.userName;
                answer.ice = [];
                info.answerToken = JSON.stringify(answer);
                console.log(`answerToken created. ${info.answerToken}`);
                await info.connection.setLocalDescription(answer);
                answerTokenInput.value = info.answerToken;
            })();
        }

        buildConnectionAsChild(index) {
            const self = this;
            const info = this.parentConnectionInfos[index];

            info.dataChannel = info.connection.createDataChannel('sendDataChannel');
            info.dataChannel.onopen = function () {
                console.log(`with ${info.connectedUserName} as child onopen`, event);
                messageSendButton.onclick = function () {
                    console.log('send message', messageInput.value);
                    (async function () {
                        if (info.isClosed || info.isSpare) {
                            return;
                        }
                        await info.dataChannel.send(Message.toJson({
                            from: self.userName, body: messageInput.value
                        }));
                    })();
                };
                if (self.messages.length === 0) {
                    (async function () {
                        await info.dataChannel.send(Message.toJson({
                            messageType: Message.JOINED_MESSAGE,
                            from: self.userName,
                            body: 'joined.'
                        }));
                    })();
                }
            }

            info.dataChannel.onmessage = function (event) {
                console.log('from parent message', event);
                const message = Message.fromJson(event.data);
                if (message.isCreateSpareOffer()) {
                    (async function () {
                        console.log('create spare offer logic start');
                        self.parentConnectionInfos = self.parentConnectionInfos.filter((i) => !i.isClosed && !i.isSpare);
                        const connectionInfo = new ConnectionInfo();
                        connectionInfo.isSpare = true;
                        const connectionNumber = node.parentConnectionInfos.push(connectionInfo);
                        node.buildConnectionAsChild(connectionNumber - 1);
                        console.log('create spare offer logic end');
                    })();
                    return;
                } else if (message.isSpareOffer()) {
                    console.log('get spare offer');
                    const tokenObj = JSON.parse(message.body);
                    if (info.connectedUserName === tokenObj.userName) {
                        message.to = self.parentConnectionInfos[0].connectedUserName;
                        message.messageType = Message.CREATE_SPARE_ANSWER_MESSAGE;
                        (async function () {
                            await self.parentConnectionInfos[0].dataChannel.send(JSON.stringify(message));
                        })();
                    }
                    return;
                } else if (message.isSpareAnswer() && message.to === self.userName) {
                    console.log('get spare answer', message);
                    const spareInfo = self.parentConnectionInfos.find((i) => i.isSpare);
                    if (spareInfo) {
                        spareInfo.answerToken = message.body;
                    }
                    return;
                } else if (message.isPastMessages()) {
                    for (let i = 0; i < message.body.length; i++) {
                        const m = message.body[i];
                        addMessageToTable(m[0], m[1], m[2], self.messages);
                    }
                    return;
                }

                (async function () {
                    for (let i = 0; i < self.childConnectionInfos.length; i++) {
                        if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                            continue;
                        }
                        await self.childConnectionInfos[i].dataChannel.send(event.data);
                    }
                })();
                if (!message.isSpareAnswer()) {
                    addMessageToTable(message.from, message.body, null, self.messages);
                }
            }
            info.dataChannel.onclose = function (event) {
                console.log('connection to parent close', index, event);
                info.isClosed = true;
                console.log(self.parentConnectionInfos);
                self.parentConnectionInfos = self.parentConnectionInfos.filter((i) => !i.isClosed);
                console.log(self.parentConnectionInfos);
                if (self.parentConnectionInfos[0]) {
                    self.parentConnectionInfos[0].isSpare = false;
                    console.log('reconnect start');
                    (async function () {
                        await loadAnswerToken();
                        for (let i = 0; i < self.childConnectionInfos.length; i++) {
                            await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                from: self.userName,
                                messageType: Message.CREATE_SPARE_OFFER_MESSAGE,
                                body: '',
                                args: [self.parentConnectionInfos[0].connectedUserName],
                            }));
                        }
                    })();
                    console.log('reconnect end');
                }
            }
            info.dataChannel.onerror = function (event) {
                console.log('connection to parent error', event);
            }
            info.connection.onicecandidate = function (event) {
                if (!event.candidate) {
                    const offerObj = JSON.parse(JSON.stringify(info.connection.localDescription));
                    offerObj.userName = self.userName;
                    info.offerToken = JSON.stringify(offerObj);
                    offerTokenInput.value = info.offerToken;
                    if (info.isSpare) {
                        (async function () {
                            await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                                from: self.userName,
                                messageType: Message.SPARE_OFFER_MESSAGE,
                                body: info.offerToken,
                            }));
                        })();
                    } else {
                        // (async function() {
                        //     const result = await fetch("http://127.0.0.1:3000/develop", {
                        //         method: 'POST',
                        //         headers: {
                        //             'Content-Type': 'application/json',
                        //         },
                        //         body: JSON.stringify({offer: offerTokenInput.value}),
                        //     });
                        //     const json = await result.json();
                        //     answerTokenInput.value = json.answer;
                        //     await loadAnswerToken();
                        // })();
                    }
                }
            };
            info.connection.onnegotiationneeded = function (event) {
                (async function () {
                    const offer = await info.connection.createOffer();
                    await info.connection.setLocalDescription(offer);
                })();
            }
        }
    }

    class ConnectionInfo {
        connectedUserName;
        connection;
        dataChannel;
        offerToken;
        answerToken;
        isAutoAnswer;
        isClosed;
        isSpare;

        constructor() {
            this.connection = new RTCPeerConnection(CONFIG_FOR_SENDER);
        }
    }

    class Message {
        static JOINED_MESSAGE = 'joined';
        static CREATE_SPARE_OFFER_MESSAGE = 'create_spare_offer';
        static SPARE_OFFER_MESSAGE = 'spare_offer';
        static CREATE_SPARE_ANSWER_MESSAGE = 'create_spare_answer';
        static SPARE_ANSWER_MESSAGE = 'spare_answer';
        static PAST_MESSAGES = 'past_messages';
        messageType;
        body;
        from;
        to;
        args;

        constructor(body, from, to, messageType, args) {
            this.from = from;
            this.to = to;
            this.messageType = messageType;
            this.body = body;
            this.args = args || [];
        }

        static fromJson(str) {
            const {from, to, messageType, body, args} = JSON.parse(str);
            return new Message(body, from, to, messageType, args);
        }

        static toJson(messageObj) {
            const {from, to, messageType, body, args} = messageObj;
            return JSON.stringify({body, from, to, messageType, args});
        }

        getBody() {
            return this.body;
        }

        isJoined() {
            return this.messageType === Message.JOINED_MESSAGE;
        }

        isCreateSpareOffer() {
            return this.messageType === Message.CREATE_SPARE_OFFER_MESSAGE;
        }

        isSpareOffer() {
            return this.messageType === Message.SPARE_OFFER_MESSAGE;
        }

        isCreateSpareAnswer() {
            return this.messageType === Message.CREATE_SPARE_ANSWER_MESSAGE;
        }

        isSpareAnswer() {
            return this.messageType === Message.SPARE_ANSWER_MESSAGE;
        }

        isPastMessages() {
            return this.messageType === Message.PAST_MESSAGES;
        }
    }

    const offerTokenButton = document.querySelector('#offer-token-button');
    const offerTokenInput = document.querySelector('#offer-token-input');
    const answerTokenButton = document.querySelector('#answer-token-button');
    const answerTokenInput = document.querySelector('#answer-token-input');
    const messageInput = document.querySelector('#message-input');
    const messageSendButton = document.querySelector('#message-send-button');
    const chatMessagesTbody = document.querySelector('#chat-messages-tbody');

    const node = new Node();

    function setOfferToken() {
        const connectionNumber = node.parentConnectionInfos.push(new ConnectionInfo());
        node.buildConnectionAsChild(connectionNumber - 1);
    }

    function setAnswerToken() {
        if (offerTokenInput.value) {
            const connectionNumber = node.childConnectionInfos.push(new ConnectionInfo());
            node.buildConnectionAsParent(connectionNumber - 1);
        }
    }

    async function loadAnswerToken() {
        const info = node.parentConnectionInfos[0];
        info.answerToken = info.answerToken || answerTokenInput.value;
        console.log('load answer token', info.answerToken);
        const answerTokenWithName = JSON.parse(info.answerToken);
        info.connectedUserName = answerTokenWithName.userName;
        await info.connection.setRemoteDescription(new RTCSessionDescription(answerTokenWithName));
    }

    function enableOfferTokenInput(isEnable) {
        if (isEnable) {
            if (offerTokenInput.value) {
                offerTokenInput.value = '';
            }
            offerTokenButton.value = '読み込む';
            offerTokenButton.onclick = setAnswerToken;
            offerTokenButton.disabled = '';
            offerTokenInput.disabled = '';
            offerTokenInput.placeholder = '参加リクエストトークンを貼り付ける';
        } else {
            setOfferToken();
            offerTokenButton.value = 'コピーする';
            offerTokenButton.onclick = function () {
                (async function () {
                    await navigator.clipboard.writeText(offerTokenInput.value);
                })();
            };
            offerTokenInput.disabled = 'disabled';
            offerTokenButton.disabled = '';
            offerTokenInput.placeholder = '';
        }
    }

    function enableAnswerTokenInput(isEnable) {
        if (isEnable) {
            answerTokenButton.value = '読み込む';
            answerTokenButton.onclick = (async function () {
                await loadAnswerToken();
            });
            answerTokenInput.disabled = '';
            answerTokenButton.disabled = '';
            answerTokenInput.placeholder = '参加許可トークンを貼り付ける';
        } else {
            answerTokenButton.value = 'コピーする';
            answerTokenButton.onclick = function () {
                (async function () {
                    await navigator.clipboard.writeText(answerTokenInput.value);
                })();
            };
            answerTokenButton.disabled = '';
            answerTokenInput.placeholder = '';
        }
    }

    function addMessageToTable(from, message, dateString, messages) {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td');
        dateString = dateString || new Date().toLocaleString();
        td1.innerText = dateString;
        tr.appendChild(td1);
        const td2 = document.createElement('td');
        td2.innerText = from;
        tr.appendChild(td2);
        const td3 = document.createElement('td');
        td3.innerText = message;
        tr.appendChild(td3);
        chatMessagesTbody.appendChild(tr);
        messages.push([from, message, dateString]);
    }

    Array.from(document.querySelectorAll('[name=join-type]')).forEach((element) => {
        element.onchange = (event) => {
            const isChild = event.target.value === 'child';
            if (isChild) {
                enableOfferTokenInput(false);
                enableAnswerTokenInput(true);
            } else {
                enableOfferTokenInput(true);
                enableAnswerTokenInput(false);
            }
        }
    });
</script>
</body>
</html>