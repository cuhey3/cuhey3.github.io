<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <title></title>
    <style>
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th, td {
            padding: 5px;
        }
    </style>
</head>
<body>
<h2>WebRTCチャット</h2>
<label>
    <input type="radio" name="join-type" value="parent"/>既存ユーザー
</label>
<label>
    <input type="radio" name="join-type" value="child"/>新規参加
</label>
<div>
    <label>
        参加リクエストトークン
        <textarea id="offer-token-input" disabled></textarea>
    </label>
    <input type="button" id="offer-token-button" value="コピーする" disabled/>
</div>
<div>
    <label>
        参加許可トークン
        <textarea id="answer-token-input" disabled></textarea>
    </label>
    <input type="button" id="answer-token-button" value="読み込む" disabled/>
</div>
<div>
    <label>
        メッセージ
        <textarea id="message-input"></textarea>
    </label>
    <input type="button" id="message-send-button" value="送信"/>
</div>
<h3>チャット</h3>
<table>
    <thead>
    <tr>
        <th>time</th>
        <th>user</th>
        <th>comment</th>
    </tr>
    </thead>
    <tbody id="chat-messages-tbody">
    </tbody>
</table>
<script>
    const CONFIG_FOR_SENDER = {
        iceServers: [
            {
                urls: "stun:stun.l.google.com:19302",
            },
        ],
    };

    class Node {
        messages;
        userName;
        parent;
        parentConnectionInfos;
        children;
        childConnectionInfos;
        level;

        constructor() {
            this.userName = Math.ceil(Math.random() * 1000);
            this.parentConnectionInfos = [];
            this.childConnectionInfos = [];
            this.messages = [];
        }

        getParentUserName() {
            return this.parentConnectionInfos[0] && this.parentConnectionInfos[0].connectedUserName;
        }

        buildConnectionAsParent(index) {
            const self = this;
            const info = self.childConnectionInfos[index];
            info.connection.onicecandidate = function (event) {
                console.log('parent ice', event);
                const answerTokenWithICE = JSON.parse(answerTokenInput.value);
                if (event.candidate) {
                    answerTokenWithICE.ice.push(event.candidate);
                    info.answerToken = JSON.stringify(answerTokenWithICE);
                    answerTokenInput.value = info.answerToken;
                } else if (info.isSpare) {
                    (async function () {
                        for (let i = 0; i < self.childConnectionInfos.length; i++) {
                            if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                continue;
                            }
                            await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                messageType: Message.SPARE_ANSWER_MESSAGE,
                                body: info.answerToken,
                                to: info.connectedUserName,
                            }));
                        }
                    })();
                }
            }

            info.dataChannel = info.connection.createDataChannel('sendDataChannel');
            info.connection.ondatachannel = function (event) {
                event.channel.onopen = function () {
                    console.log(`with ${info.connectedUserName} as parent onopen`);
                    // parent の場合は、より親に送るか、子供全員に送るかで、
                    // その処理を接続確立のたびにセットするのはおかしい
                    messageSendButton.onclick = function () {
                        if (self.parentConnectionInfos[0] && !self.parentConnectionInfos[0].isClosed && !self.childConnectionInfos[0].isSpare) {
                            console.log('send message to parent', messageInput.value);
                            (async function () {
                                await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                                    from: self.userName,
                                    body: messageInput.value
                                }));
                            })();
                        } else {
                            console.log('send message to children', messageInput.value);
                            (async function () {
                                for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                    if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                        continue;
                                    }
                                    await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                        from: self.userName,
                                        body: messageInput.value,
                                    }));
                                }
                                addMessageToTable(self.userName, messageInput.value, null, self.messages);
                            })();
                        }
                    };
                    // (async function () {
                    //     await hostSendChannels[index].send(JSON.stringify({
                    //         userName: 'host',
                    //         messageType: JOINED_MESSAGE,
                    //         body: 'joined.'
                    //     }));
                    //     addMessageToTable('host', Message.JOINED_MESSAGE);
                    // })();
                    if (self.parentConnectionInfos[0]) {
                        (async function () {
                            await info.dataChannel.send(Message.toJson({
                                from: self.userName,
                                messageType: Message.CREATE_SPARE_OFFER_MESSAGE,
                                body: '',
                                args: [self.parentConnectionInfos[0].connectedUserName],
                            }));
                        })();
                    }
                    if (!info.isSpare) {
                        (async function () {
                            await info.dataChannel.send(Message.toJson({
                                messageType: Message.PAST_MESSAGES,
                                body: self.messages,
                            }));
                            if (!self.parentConnectionInfos[0] && self.childConnectionInfos.length === 1) {
                                await info.dataChannel.send(Message.toJson({
                                    messageType: Message.JOINED_MESSAGE,
                                    from: self.userName,
                                    body: 'joined.'
                                }));
                                addMessageToTable(self.userName, 'joined.', null, self.messages);
                            }
                        })();
                    }
                    info.isSpare = false;
                }

                event.channel.onmessage = function (event) {
                    console.log('from child message', event);
                    const message = Message.fromJson(event.data);
                    // // ゲスト二人目以降はスペアのoffer作成リクエストを送信する
                    // if (message.isJoined() && index > 0) {
                    //     (async function () {
                    //         await hostSendChannels[index].send(Message.toJson({
                    //             userName: 'host',
                    //             messageType: Message.CREATE_SPARE_OFFER_MESSAGE,
                    //             body: Message.CREATE_SPARE_OFFER_MESSAGE
                    //         }));
                    //         addMessageToTable('host', Message.CREATE_SPARE_OFFER_MESSAGE);
                    //     })();
                    // } else
                    if (message.isSpareOffer()) {
                        (async function () {
                            await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                                userName: self.userName,
                                messageType: Message.CREATE_SPARE_ANSWER_MESSAGE,
                                body: message.body,
                                to: self.parentConnectionInfos[0].connectedUserName,
                            }));
                        })();
                        return;
                    } else if (message.isCreateSpareAnswer() && message.to === self.userName) {
                        console.log('get spare offer', message.body);
                        console.log('create spare answer logic start');
                        offerTokenInput.value = message.body;
                        const connectionInfo = new ConnectionInfo();
                        connectionInfo.isSpare = true;
                        connectionInfo.connectedUserName = JSON.parse(message.body).userName;
                        const connectionNumber = node.childConnectionInfos.push(connectionInfo);
                        node.buildConnectionAsParent(connectionNumber - 1);
                        console.log('create spare answer logic end');
                        return;
                    }
                    // else if (message.isSpareAnswer()) {
                    //     (async function(){
                    //         //
                    //         await hostSendChannels[hostSendChannels.length - 1].send(Message.toJson({
                    //             userName: 'host',
                    //             messageType: Message.SPARE_ANSWER_MESSAGE,
                    //             body: message.body
                    //         }));
                    //     })();
                    //     return;
                    // }
                    (async function () {
                        if (self.parentConnectionInfos[0] && !self.parentConnectionInfos[0].isClosed && !self.childConnectionInfos[0].isSpare) {
                            await self.parentConnectionInfos[0].dataChannel.send(event.data);
                        } else {
                            for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                    continue;
                                }
                                await self.childConnectionInfos[i].dataChannel.send(event.data);
                            }
                            addMessageToTable(message.from, message.body, null, self.messages);
                        }
                    })();
                }
                event.channel.onclose = function (event) {
                    info.isClosed = true;
                }
                event.channel.onerror = function (event) {
                    console.log('child connection error', event);
                }
            };
            (async function () {
                await (async () => {
                    const offerTokenWithICE = JSON.parse(offerTokenInput.value);
                    info.connectedUserName = offerTokenWithICE.userName;
                    await info.connection.setRemoteDescription(JSON.parse(offerTokenInput.value));
                    const answer = await info.connection.createAnswer();
                    answer.userName = self.userName;
                    answer.ice = [];
                    info.answerToken = JSON.stringify(answer);
                    console.log(`answerToken created. ${info.answerToken}`);
                    await info.connection.setLocalDescription(answer);
                    answerTokenInput.value = info.answerToken;
                    for (let i = 0; i < offerTokenWithICE.ice.length; i++) {
                        if (offerTokenWithICE.ice[i]) {
                            await info.connection.addIceCandidate(new RTCIceCandidate(offerTokenWithICE.ice[i]));
                        }
                    }
                })();
            })();
        }

        buildConnectionAsChild(index) {
            const self = this;
            const info = this.parentConnectionInfos[index];
            info.connection.onicecandidate = function (event) {
                console.log('child ice', event);
                const offerTokenWithICE = JSON.parse(info.offerToken);
                if (event.candidate) {
                    offerTokenWithICE.ice.push(event.candidate);
                    info.offerToken = JSON.stringify(offerTokenWithICE);
                    offerTokenInput.value = info.offerToken;
                } else if (info.isSpare) {
                    (async function () {
                        await self.parentConnectionInfos[0].dataChannel.send(Message.toJson({
                            from: self.userName,
                            messageType: Message.SPARE_OFFER_MESSAGE,
                            body: info.offerToken,
                        }));
                    })();
                }
            }

            info.dataChannel = info.connection.createDataChannel('sendDataChannel');
            info.connection.ondatachannel = function (event) {
                event.channel.onopen = function () {
                    console.log(`with ${info.connectedUserName} as child onopen`, event);
                    messageSendButton.onclick = function () {
                        console.log('send message', messageInput.value);
                        (async function () {
                            if (info.isClosed || info.isSpare) {
                                return;
                            }
                            await info.dataChannel.send(Message.toJson({
                                from: self.userName, body: messageInput.value
                            }));
                        })();
                    };
                    if (self.messages.length === 0) {
                        (async function () {
                            await info.dataChannel.send(Message.toJson({
                                messageType: Message.JOINED_MESSAGE,
                                from: self.userName,
                                body: 'joined.'
                            }));
                        })();
                    }
                }

                event.channel.onmessage = function (event) {
                    console.log('from parent message', event);
                    const message = Message.fromJson(event.data);
                    if (message.isCreateSpareOffer()) {
                        (async function () {
                            console.log('create spare offer logic start');
                            self.parentConnectionInfos = self.parentConnectionInfos.filter((i) => !i.isClosed && !i.isSpare);
                            const connectionInfo = new ConnectionInfo();
                            connectionInfo.isSpare = true;
                            const connectionNumber = node.parentConnectionInfos.push(connectionInfo);
                            node.buildConnectionAsChild(connectionNumber - 1);
                            console.log('create spare offer logic end');
                        })();
                        return;
                    } else if (message.isSpareOffer()) {
                        console.log('get spare offer');
                        const tokenObj = JSON.parse(message.body);
                        if (info.connectedUserName === tokenObj.userName) {
                            message.to = self.parentConnectionInfos[0].connectedUserName;
                            message.messageType = Message.CREATE_SPARE_ANSWER_MESSAGE;
                            (async function () {
                                await self.parentConnectionInfos[0].dataChannel.send(JSON.stringify(message));
                            })();
                        }
                        return;
                    } else if (message.isSpareAnswer() && message.to === self.userName) {
                        console.log('get spare answer', message);
                        const spareInfo = self.parentConnectionInfos.find((i) => i.isSpare);
                        if (spareInfo) {
                            spareInfo.answerToken = message.body;
                        }
                        return;
                    } else if (message.isPastMessages()) {
                        for (let i = 0; i < message.body.length; i++) {
                            const m = message.body[i];
                            addMessageToTable(m[0], m[1], m[2], self.messages);
                        }
                        return;
                    }

                    (async function () {
                        for (let i = 0; i < self.childConnectionInfos.length; i++) {
                            if (self.childConnectionInfos[i].isClosed || self.childConnectionInfos[i].isSpare) {
                                continue;
                            }
                            await self.childConnectionInfos[i].dataChannel.send(event.data);
                        }
                    })();
                    if (!message.isSpareAnswer()) {
                        addMessageToTable(message.from, message.body, null, self.messages);
                    }
                }
                event.channel.onclose = function (event) {
                    console.log('connection to parent close', index, event);
                    info.isClosed = true;
                    console.log(self.parentConnectionInfos);
                    self.parentConnectionInfos = self.parentConnectionInfos.filter((i) => !i.isClosed);
                    console.log(self.parentConnectionInfos);
                    if (self.parentConnectionInfos[0]
                        // && self.parentConnectionInfos[0].isSpare
                    ) {
                        self.parentConnectionInfos[0].isSpare = false;
                        console.log('reconnect start');
                        (async function () {
                            await loadAnswerToken();
                            for (let i = 0; i < self.childConnectionInfos.length; i++) {
                                await self.childConnectionInfos[i].dataChannel.send(Message.toJson({
                                    from: self.userName,
                                    messageType: Message.CREATE_SPARE_OFFER_MESSAGE,
                                    body: '',
                                    args: [self.parentConnectionInfos[0].connectedUserName],
                                }));
                            }
                        })();
                        console.log('reconnect end');
                    }
                }
                event.channel.onerror = function (event) {
                    console.log('connection to parent error', event);
                }
            };
            (async function () {
                const offer = await info.connection.createOffer();
                await info.connection.setLocalDescription(offer);
                offer.userName = self.userName;
                offer.ice = [];
                info.offerToken = JSON.stringify(offer);
                console.log(`offerToken created. ${info.offerToken}`);
                offerTokenInput.value = info.offerToken;
            })();
        }
    }

    class ConnectionInfo {
        connectedUserName;
        connection;
        dataChannel;
        offerToken;
        answerToken;
        isAutoAnswer;
        isClosed;
        isSpare;

        constructor() {
            this.connection = new RTCPeerConnection(CONFIG_FOR_SENDER);
        }
    }

    class Message {
        static JOINED_MESSAGE = 'joined';
        static CREATE_SPARE_OFFER_MESSAGE = 'create_spare_offer';
        static SPARE_OFFER_MESSAGE = 'spare_offer';
        static CREATE_SPARE_ANSWER_MESSAGE = 'create_spare_answer';
        static SPARE_ANSWER_MESSAGE = 'spare_answer';
        static PAST_MESSAGES = 'past_messages';
        messageType;
        body;
        from;
        to;
        args;

        constructor(body, from, to, messageType, args) {
            this.from = from;
            this.to = to;
            this.messageType = messageType;
            this.body = body;
            this.args = args || [];
        }

        static fromJson(str) {
            const {from, to, messageType, body, args} = JSON.parse(str);
            return new Message(body, from, to, messageType, args);
        }

        static toJson(messageObj) {
            const {from, to, messageType, body, args} = messageObj;
            return JSON.stringify({body, from, to, messageType, args});
        }

        getBody() {
            return this.body;
        }

        isJoined() {
            return this.messageType === Message.JOINED_MESSAGE;
        }

        isCreateSpareOffer() {
            return this.messageType === Message.CREATE_SPARE_OFFER_MESSAGE;
        }

        isSpareOffer() {
            return this.messageType === Message.SPARE_OFFER_MESSAGE;
        }

        isCreateSpareAnswer() {
            return this.messageType === Message.CREATE_SPARE_ANSWER_MESSAGE;
        }

        isSpareAnswer() {
            return this.messageType === Message.SPARE_ANSWER_MESSAGE;
        }

        isPastMessages() {
            return this.messageType === Message.PAST_MESSAGES;
        }
    }

    const offerTokenButton = document.querySelector('#offer-token-button');
    const offerTokenInput = document.querySelector('#offer-token-input');
    const answerTokenButton = document.querySelector('#answer-token-button');
    const answerTokenInput = document.querySelector('#answer-token-input');
    const messageInput = document.querySelector('#message-input');
    const messageSendButton = document.querySelector('#message-send-button');
    const chatMessagesTbody = document.querySelector('#chat-messages-tbody');

    const node = new Node();

    function setOfferToken() {
        const connectionNumber = node.parentConnectionInfos.push(new ConnectionInfo());
        node.buildConnectionAsChild(connectionNumber - 1);
    }

    function setAnswerToken() {
        if (offerTokenInput.value) {
            const connectionNumber = node.childConnectionInfos.push(new ConnectionInfo());
            node.buildConnectionAsParent(connectionNumber - 1);
        }
    }

    async function loadAnswerToken() {
        const info = node.parentConnectionInfos[0];
        info.answerToken = info.answerToken || answerTokenInput.value;
        console.log('load answer token', info.answerToken);
        const answerTokenWithICE = JSON.parse(info.answerToken);
        info.connectedUserName = answerTokenWithICE.userName;
        await info.connection.setRemoteDescription(answerTokenWithICE);
        for (let i = 0; i < answerTokenWithICE.ice.length; i++) {
            if (answerTokenWithICE.ice[i]) {
                console.log('hoge');
                await info.connection.addIceCandidate(new RTCIceCandidate(answerTokenWithICE.ice[i]));
            }
        }
    }

    function enableOfferTokenInput(isEnable) {
        if (isEnable) {
            if (offerTokenInput.value) {
                offerTokenInput.value = '';
            }
            offerTokenButton.value = '読み込む';
            offerTokenButton.onclick = setAnswerToken;
            offerTokenButton.disabled = '';
            offerTokenInput.disabled = '';
            offerTokenInput.placeholder = '参加リクエストトークンを貼り付ける';
        } else {
            setOfferToken();
            offerTokenButton.value = 'コピーする';
            offerTokenButton.onclick = function () {
                (async function () {
                    await navigator.clipboard.writeText(offerTokenInput.value);
                })();
            };
            offerTokenInput.disabled = 'disabled';
            offerTokenButton.disabled = '';
            offerTokenInput.placeholder = '';
        }
    }

    function enableAnswerTokenInput(isEnable) {
        if (isEnable) {
            answerTokenButton.value = '読み込む';
            answerTokenButton.onclick = (async function () {
                await loadAnswerToken();
            });
            answerTokenInput.disabled = '';
            answerTokenButton.disabled = '';
            answerTokenInput.placeholder = '参加許可トークンを貼り付ける';
        } else {
            answerTokenButton.value = 'コピーする';
            answerTokenButton.onclick = function () {
                (async function () {
                    await navigator.clipboard.writeText(answerTokenInput.value);
                })();
            };
            answerTokenButton.disabled = '';
            answerTokenInput.placeholder = '';
        }
    }

    function addMessageToTable(from, message, dateString, messages) {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td');
        dateString = dateString || new Date().toLocaleString();
        td1.innerText = dateString;
        tr.appendChild(td1);
        const td2 = document.createElement('td');
        td2.innerText = from;
        tr.appendChild(td2);
        const td3 = document.createElement('td');
        td3.innerText = message;
        tr.appendChild(td3);
        chatMessagesTbody.appendChild(tr);
        messages.push([from, message, dateString]);
    }

    Array.from(document.querySelectorAll('[name=join-type]')).forEach((element) => {
        element.onchange = (event) => {
            const isChild = event.target.value === 'child';
            if (isChild) {
                enableOfferTokenInput(false);
                enableAnswerTokenInput(true);
            } else {
                enableOfferTokenInput(true);
                enableAnswerTokenInput(false);
            }
        }
    });
</script>
</body>
</html>